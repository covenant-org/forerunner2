// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: registry.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(ad571514d922b940);
enum class RequestType_ad571514d922b940: uint16_t {
  ADD_NODE,
  QUERY_NODE,
};
CAPNP_DECLARE_ENUM(RequestType, ad571514d922b940);
CAPNP_DECLARE_SCHEMA(ac0946294045fa6c);
CAPNP_DECLARE_SCHEMA(c8f54b8c51130646);
CAPNP_DECLARE_SCHEMA(c79d291c7f91311d);
CAPNP_DECLARE_SCHEMA(beb5c98b7ec7be5a);
CAPNP_DECLARE_SCHEMA(e313239c1875a12b);
CAPNP_DECLARE_SCHEMA(958ab110a91a2636);
CAPNP_DECLARE_SCHEMA(bc03c4ab542e5747);
enum class RegistryNotificationType_bc03c4ab542e5747: uint16_t {
  NODE_ADDED,
  NODE_DELETED,
};
CAPNP_DECLARE_ENUM(RegistryNotificationType, bc03c4ab542e5747);
CAPNP_DECLARE_SCHEMA(933ae650ec6dd8aa);
CAPNP_DECLARE_SCHEMA(ab9b03a7cf286214);
CAPNP_DECLARE_SCHEMA(ff75a2405fdf10f3);

}  // namespace schemas
}  // namespace capnp


typedef ::capnp::schemas::RequestType_ad571514d922b940 RequestType;

struct RegistryRequest {
  RegistryRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    ADD_NODE,
    QUERY_NODE,
  };
  struct AddNode;
  struct QueryNode;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac0946294045fa6c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RegistryRequest::AddNode {
  AddNode() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c8f54b8c51130646, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RegistryRequest::QueryNode {
  QueryNode() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c79d291c7f91311d, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RegistryResponse {
  RegistryResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    QUERY_NODE,
    ADD_NODE,
  };
  struct QueryNode;
  struct AddNode;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(beb5c98b7ec7be5a, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RegistryResponse::QueryNode {
  QueryNode() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e313239c1875a12b, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RegistryResponse::AddNode {
  AddNode() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(958ab110a91a2636, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::RegistryNotificationType_bc03c4ab542e5747 RegistryNotificationType;

struct RegistryNotification {
  RegistryNotification() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NODE_ADDED,
    NODE_DELETED,
  };
  struct NodeAdded;
  struct NodeDeleted;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(933ae650ec6dd8aa, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RegistryNotification::NodeAdded {
  NodeAdded() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab9b03a7cf286214, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RegistryNotification::NodeDeleted {
  NodeDeleted() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff75a2405fdf10f3, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class RegistryRequest::Reader {
public:
  typedef RegistryRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::RequestType getType() const;

  inline bool isAddNode() const;
  inline typename AddNode::Reader getAddNode() const;

  inline bool isQueryNode() const;
  inline typename QueryNode::Reader getQueryNode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryRequest::Builder {
public:
  typedef RegistryRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::RequestType getType();
  inline void setType( ::RequestType value);

  inline bool isAddNode();
  inline typename AddNode::Builder getAddNode();
  inline typename AddNode::Builder initAddNode();

  inline bool isQueryNode();
  inline typename QueryNode::Builder getQueryNode();
  inline typename QueryNode::Builder initQueryNode();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryRequest::Pipeline {
public:
  typedef RegistryRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RegistryRequest::AddNode::Reader {
public:
  typedef AddNode Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPath() const;
  inline  ::capnp::Text::Reader getPath() const;

  inline  ::uint32_t getPort() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryRequest::AddNode::Builder {
public:
  typedef AddNode Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPath();
  inline  ::capnp::Text::Builder getPath();
  inline void setPath( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPath(unsigned int size);
  inline void adoptPath(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPath();

  inline  ::uint32_t getPort();
  inline void setPort( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryRequest::AddNode::Pipeline {
public:
  typedef AddNode Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RegistryRequest::QueryNode::Reader {
public:
  typedef QueryNode Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPath() const;
  inline  ::capnp::Text::Reader getPath() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryRequest::QueryNode::Builder {
public:
  typedef QueryNode Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPath();
  inline  ::capnp::Text::Builder getPath();
  inline void setPath( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPath(unsigned int size);
  inline void adoptPath(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPath();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryRequest::QueryNode::Pipeline {
public:
  typedef QueryNode Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RegistryResponse::Reader {
public:
  typedef RegistryResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getCode() const;

  inline bool hasErrorMessage() const;
  inline  ::capnp::Text::Reader getErrorMessage() const;

  inline bool isQueryNode() const;
  inline typename QueryNode::Reader getQueryNode() const;

  inline bool isAddNode() const;
  inline typename AddNode::Reader getAddNode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryResponse::Builder {
public:
  typedef RegistryResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getCode();
  inline void setCode( ::uint32_t value);

  inline bool hasErrorMessage();
  inline  ::capnp::Text::Builder getErrorMessage();
  inline void setErrorMessage( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initErrorMessage(unsigned int size);
  inline void adoptErrorMessage(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownErrorMessage();

  inline bool isQueryNode();
  inline typename QueryNode::Builder getQueryNode();
  inline typename QueryNode::Builder initQueryNode();

  inline bool isAddNode();
  inline typename AddNode::Builder getAddNode();
  inline typename AddNode::Builder initAddNode();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryResponse::Pipeline {
public:
  typedef RegistryResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RegistryResponse::QueryNode::Reader {
public:
  typedef QueryNode Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPort() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryResponse::QueryNode::Builder {
public:
  typedef QueryNode Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPort();
  inline void setPort( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryResponse::QueryNode::Pipeline {
public:
  typedef QueryNode Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RegistryResponse::AddNode::Reader {
public:
  typedef AddNode Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPort() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryResponse::AddNode::Builder {
public:
  typedef AddNode Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPort();
  inline void setPort( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryResponse::AddNode::Pipeline {
public:
  typedef AddNode Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RegistryNotification::Reader {
public:
  typedef RegistryNotification Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::RegistryNotificationType getType() const;

  inline bool isNodeAdded() const;
  inline typename NodeAdded::Reader getNodeAdded() const;

  inline bool isNodeDeleted() const;
  inline typename NodeDeleted::Reader getNodeDeleted() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryNotification::Builder {
public:
  typedef RegistryNotification Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::RegistryNotificationType getType();
  inline void setType( ::RegistryNotificationType value);

  inline bool isNodeAdded();
  inline typename NodeAdded::Builder getNodeAdded();
  inline typename NodeAdded::Builder initNodeAdded();

  inline bool isNodeDeleted();
  inline typename NodeDeleted::Builder getNodeDeleted();
  inline typename NodeDeleted::Builder initNodeDeleted();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryNotification::Pipeline {
public:
  typedef RegistryNotification Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RegistryNotification::NodeAdded::Reader {
public:
  typedef NodeAdded Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPath() const;
  inline  ::capnp::Text::Reader getPath() const;

  inline  ::uint32_t getPort() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryNotification::NodeAdded::Builder {
public:
  typedef NodeAdded Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPath();
  inline  ::capnp::Text::Builder getPath();
  inline void setPath( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPath(unsigned int size);
  inline void adoptPath(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPath();

  inline  ::uint32_t getPort();
  inline void setPort( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryNotification::NodeAdded::Pipeline {
public:
  typedef NodeAdded Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RegistryNotification::NodeDeleted::Reader {
public:
  typedef NodeDeleted Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPath() const;
  inline  ::capnp::Text::Reader getPath() const;

  inline  ::uint32_t getPort() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RegistryNotification::NodeDeleted::Builder {
public:
  typedef NodeDeleted Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPath();
  inline  ::capnp::Text::Builder getPath();
  inline void setPath( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPath(unsigned int size);
  inline void adoptPath(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPath();

  inline  ::uint32_t getPort();
  inline void setPort( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RegistryNotification::NodeDeleted::Pipeline {
public:
  typedef NodeDeleted Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::RegistryRequest::Which RegistryRequest::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::RegistryRequest::Which RegistryRequest::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::RequestType RegistryRequest::Reader::getType() const {
  return _reader.getDataField< ::RequestType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::RequestType RegistryRequest::Builder::getType() {
  return _builder.getDataField< ::RequestType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RegistryRequest::Builder::setType( ::RequestType value) {
  _builder.setDataField< ::RequestType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RegistryRequest::Reader::isAddNode() const {
  return which() == RegistryRequest::ADD_NODE;
}
inline bool RegistryRequest::Builder::isAddNode() {
  return which() == RegistryRequest::ADD_NODE;
}
inline typename RegistryRequest::AddNode::Reader RegistryRequest::Reader::getAddNode() const {
  KJ_IREQUIRE((which() == RegistryRequest::ADD_NODE),
              "Must check which() before get()ing a union member.");
  return typename RegistryRequest::AddNode::Reader(_reader);
}
inline typename RegistryRequest::AddNode::Builder RegistryRequest::Builder::getAddNode() {
  KJ_IREQUIRE((which() == RegistryRequest::ADD_NODE),
              "Must check which() before get()ing a union member.");
  return typename RegistryRequest::AddNode::Builder(_builder);
}
inline typename RegistryRequest::AddNode::Builder RegistryRequest::Builder::initAddNode() {
  _builder.setDataField<RegistryRequest::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, RegistryRequest::ADD_NODE);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename RegistryRequest::AddNode::Builder(_builder);
}
inline bool RegistryRequest::Reader::isQueryNode() const {
  return which() == RegistryRequest::QUERY_NODE;
}
inline bool RegistryRequest::Builder::isQueryNode() {
  return which() == RegistryRequest::QUERY_NODE;
}
inline typename RegistryRequest::QueryNode::Reader RegistryRequest::Reader::getQueryNode() const {
  KJ_IREQUIRE((which() == RegistryRequest::QUERY_NODE),
              "Must check which() before get()ing a union member.");
  return typename RegistryRequest::QueryNode::Reader(_reader);
}
inline typename RegistryRequest::QueryNode::Builder RegistryRequest::Builder::getQueryNode() {
  KJ_IREQUIRE((which() == RegistryRequest::QUERY_NODE),
              "Must check which() before get()ing a union member.");
  return typename RegistryRequest::QueryNode::Builder(_builder);
}
inline typename RegistryRequest::QueryNode::Builder RegistryRequest::Builder::initQueryNode() {
  _builder.setDataField<RegistryRequest::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, RegistryRequest::QUERY_NODE);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename RegistryRequest::QueryNode::Builder(_builder);
}
inline bool RegistryRequest::AddNode::Reader::hasPath() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RegistryRequest::AddNode::Builder::hasPath() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RegistryRequest::AddNode::Reader::getPath() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RegistryRequest::AddNode::Builder::getPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RegistryRequest::AddNode::Builder::setPath( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RegistryRequest::AddNode::Builder::initPath(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RegistryRequest::AddNode::Builder::adoptPath(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RegistryRequest::AddNode::Builder::disownPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t RegistryRequest::AddNode::Reader::getPort() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RegistryRequest::AddNode::Builder::getPort() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RegistryRequest::AddNode::Builder::setPort( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool RegistryRequest::QueryNode::Reader::hasPath() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RegistryRequest::QueryNode::Builder::hasPath() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RegistryRequest::QueryNode::Reader::getPath() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RegistryRequest::QueryNode::Builder::getPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RegistryRequest::QueryNode::Builder::setPath( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RegistryRequest::QueryNode::Builder::initPath(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RegistryRequest::QueryNode::Builder::adoptPath(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RegistryRequest::QueryNode::Builder::disownPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::RegistryResponse::Which RegistryResponse::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::RegistryResponse::Which RegistryResponse::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RegistryResponse::Reader::getCode() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RegistryResponse::Builder::getCode() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RegistryResponse::Builder::setCode( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RegistryResponse::Reader::hasErrorMessage() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RegistryResponse::Builder::hasErrorMessage() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RegistryResponse::Reader::getErrorMessage() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RegistryResponse::Builder::getErrorMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RegistryResponse::Builder::setErrorMessage( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RegistryResponse::Builder::initErrorMessage(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RegistryResponse::Builder::adoptErrorMessage(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RegistryResponse::Builder::disownErrorMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RegistryResponse::Reader::isQueryNode() const {
  return which() == RegistryResponse::QUERY_NODE;
}
inline bool RegistryResponse::Builder::isQueryNode() {
  return which() == RegistryResponse::QUERY_NODE;
}
inline typename RegistryResponse::QueryNode::Reader RegistryResponse::Reader::getQueryNode() const {
  KJ_IREQUIRE((which() == RegistryResponse::QUERY_NODE),
              "Must check which() before get()ing a union member.");
  return typename RegistryResponse::QueryNode::Reader(_reader);
}
inline typename RegistryResponse::QueryNode::Builder RegistryResponse::Builder::getQueryNode() {
  KJ_IREQUIRE((which() == RegistryResponse::QUERY_NODE),
              "Must check which() before get()ing a union member.");
  return typename RegistryResponse::QueryNode::Builder(_builder);
}
inline typename RegistryResponse::QueryNode::Builder RegistryResponse::Builder::initQueryNode() {
  _builder.setDataField<RegistryResponse::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, RegistryResponse::QUERY_NODE);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename RegistryResponse::QueryNode::Builder(_builder);
}
inline bool RegistryResponse::Reader::isAddNode() const {
  return which() == RegistryResponse::ADD_NODE;
}
inline bool RegistryResponse::Builder::isAddNode() {
  return which() == RegistryResponse::ADD_NODE;
}
inline typename RegistryResponse::AddNode::Reader RegistryResponse::Reader::getAddNode() const {
  KJ_IREQUIRE((which() == RegistryResponse::ADD_NODE),
              "Must check which() before get()ing a union member.");
  return typename RegistryResponse::AddNode::Reader(_reader);
}
inline typename RegistryResponse::AddNode::Builder RegistryResponse::Builder::getAddNode() {
  KJ_IREQUIRE((which() == RegistryResponse::ADD_NODE),
              "Must check which() before get()ing a union member.");
  return typename RegistryResponse::AddNode::Builder(_builder);
}
inline typename RegistryResponse::AddNode::Builder RegistryResponse::Builder::initAddNode() {
  _builder.setDataField<RegistryResponse::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, RegistryResponse::ADD_NODE);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename RegistryResponse::AddNode::Builder(_builder);
}
inline  ::uint32_t RegistryResponse::QueryNode::Reader::getPort() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RegistryResponse::QueryNode::Builder::getPort() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RegistryResponse::QueryNode::Builder::setPort( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t RegistryResponse::AddNode::Reader::getPort() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RegistryResponse::AddNode::Builder::getPort() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RegistryResponse::AddNode::Builder::setPort( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::RegistryNotification::Which RegistryNotification::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::RegistryNotification::Which RegistryNotification::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::RegistryNotificationType RegistryNotification::Reader::getType() const {
  return _reader.getDataField< ::RegistryNotificationType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::RegistryNotificationType RegistryNotification::Builder::getType() {
  return _builder.getDataField< ::RegistryNotificationType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RegistryNotification::Builder::setType( ::RegistryNotificationType value) {
  _builder.setDataField< ::RegistryNotificationType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RegistryNotification::Reader::isNodeAdded() const {
  return which() == RegistryNotification::NODE_ADDED;
}
inline bool RegistryNotification::Builder::isNodeAdded() {
  return which() == RegistryNotification::NODE_ADDED;
}
inline typename RegistryNotification::NodeAdded::Reader RegistryNotification::Reader::getNodeAdded() const {
  KJ_IREQUIRE((which() == RegistryNotification::NODE_ADDED),
              "Must check which() before get()ing a union member.");
  return typename RegistryNotification::NodeAdded::Reader(_reader);
}
inline typename RegistryNotification::NodeAdded::Builder RegistryNotification::Builder::getNodeAdded() {
  KJ_IREQUIRE((which() == RegistryNotification::NODE_ADDED),
              "Must check which() before get()ing a union member.");
  return typename RegistryNotification::NodeAdded::Builder(_builder);
}
inline typename RegistryNotification::NodeAdded::Builder RegistryNotification::Builder::initNodeAdded() {
  _builder.setDataField<RegistryNotification::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, RegistryNotification::NODE_ADDED);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename RegistryNotification::NodeAdded::Builder(_builder);
}
inline bool RegistryNotification::Reader::isNodeDeleted() const {
  return which() == RegistryNotification::NODE_DELETED;
}
inline bool RegistryNotification::Builder::isNodeDeleted() {
  return which() == RegistryNotification::NODE_DELETED;
}
inline typename RegistryNotification::NodeDeleted::Reader RegistryNotification::Reader::getNodeDeleted() const {
  KJ_IREQUIRE((which() == RegistryNotification::NODE_DELETED),
              "Must check which() before get()ing a union member.");
  return typename RegistryNotification::NodeDeleted::Reader(_reader);
}
inline typename RegistryNotification::NodeDeleted::Builder RegistryNotification::Builder::getNodeDeleted() {
  KJ_IREQUIRE((which() == RegistryNotification::NODE_DELETED),
              "Must check which() before get()ing a union member.");
  return typename RegistryNotification::NodeDeleted::Builder(_builder);
}
inline typename RegistryNotification::NodeDeleted::Builder RegistryNotification::Builder::initNodeDeleted() {
  _builder.setDataField<RegistryNotification::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, RegistryNotification::NODE_DELETED);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename RegistryNotification::NodeDeleted::Builder(_builder);
}
inline bool RegistryNotification::NodeAdded::Reader::hasPath() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RegistryNotification::NodeAdded::Builder::hasPath() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RegistryNotification::NodeAdded::Reader::getPath() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RegistryNotification::NodeAdded::Builder::getPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RegistryNotification::NodeAdded::Builder::setPath( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RegistryNotification::NodeAdded::Builder::initPath(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RegistryNotification::NodeAdded::Builder::adoptPath(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RegistryNotification::NodeAdded::Builder::disownPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t RegistryNotification::NodeAdded::Reader::getPort() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RegistryNotification::NodeAdded::Builder::getPort() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RegistryNotification::NodeAdded::Builder::setPort( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool RegistryNotification::NodeDeleted::Reader::hasPath() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RegistryNotification::NodeDeleted::Builder::hasPath() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RegistryNotification::NodeDeleted::Reader::getPath() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RegistryNotification::NodeDeleted::Builder::getPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RegistryNotification::NodeDeleted::Builder::setPath( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RegistryNotification::NodeDeleted::Builder::initPath(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RegistryNotification::NodeDeleted::Builder::adoptPath(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RegistryNotification::NodeDeleted::Builder::disownPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t RegistryNotification::NodeDeleted::Reader::getPort() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t RegistryNotification::NodeDeleted::Builder::getPort() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RegistryNotification::NodeDeleted::Builder::setPort( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}


CAPNP_END_HEADER

